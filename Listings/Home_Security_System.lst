C51 COMPILER V9.56.0.0   HOME_SECURITY_SYSTEM                                              12/07/2017 19:12:45 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE HOME_SECURITY_SYSTEM
OBJECT MODULE PLACED IN .\Objects\Home_Security_System.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Home_Security_System.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT
                    -(.\Listings\Home_Security_System.lst) TABS(2) OBJECT(.\Objects\Home_Security_System.obj)

line level    source

   1          //////////////////////////////////
   2          //     Home Security System     //
   3          //////////////////////////////////
   4          
   5          #include <reg51.h>
   6          
   7          
   8          #define COMMAND 0
   9          #define LCD_DATA 1
  10          
  11          //Declaring Port Pins
  12          //P0
  13          sbit ARM = P0^0;
  14          //P1
  15          sbit LED0 = P1^0;
  16          sbit LED1 = P1^1;
  17          sbit LaserSwitch = P1^2;
  18          sbit EncB = P1^3;
  19          sbit GREEN = P1^5;
  20          sbit YELLOW = P1^6;
  21          sbit RED = P1^7;
  22          //P2
  23          #define ldata P2
  24          sbit busy = P2^7; // connected to DB7 on the LCD
  25          //P3
  26          sbit EncA = P3^2;
  27          sbit BREAK = P3^3;
  28          sbit rw = P3^5;
  29          sbit rs = P3^6;
  30          sbit en = P3^7;
  31          
  32          //variables
  33          unsigned int countDownNum = 7;
  34          unsigned int prevTime;
  35          
  36          unsigned int dir;//1 = cw, -1 = ccw
  37          bit update;//0 = stay same,1 = update
  38          
  39          unsigned int time = 50; //  Default:50 (99-7)/2 = 46, rounded up
  40          unsigned int delayVal = 0;
  41          
  42          //bit variables to keep track of state
  43          bit ARMED = 0;//countdown finishes
  44          bit timer;
  45          bit Laser_Break = 0;
  46          
  47          //Interrupt functions
  48          void timer1(void) interrupt 3{//50ms 
  49   1        TR1 = 0;//turn timer off
  50   1        delayVal = delayVal - 1;//decrease delay value
  51   1        TH1 = 0x4B;//initial values
  52   1        TL1 = 0x92;
  53   1      }
  54          
C51 COMPILER V9.56.0.0   HOME_SECURITY_SYSTEM                                              12/07/2017 19:12:45 PAGE 2   

  55          void breakBeam() interrupt 2//senses if beam is broken
  56          {
  57   1        Laser_Break = 1;//flag to check if beam is broken
  58   1      }
  59          void delay()//delay 1 second
  60          {
  61   1        delayVal = 20;
  62   1        while(delayVal > 0)
  63   1        {
  64   2          TR1 = 1;
  65   2        }
  66   1        TR1 = 0;
  67   1      }
  68          void delayHalf()//delay 0.5 second
  69          {
  70   1        delayVal = 10;
  71   1        while(delayVal > 0)
  72   1        {
  73   2          TR1 = 1;
  74   2        }
  75   1        TR1 = 0;
  76   1      }
  77          void delayOneTen()
  78          {
  79   1        delayVal = 3;
  80   1        while(delayVal > 0)
  81   1        {
  82   2          TR1 = 1;
  83   2        }
  84   1        TR1 = 0;
  85   1      }
  86          //State Functions
  87          void disarmedState();
  88          void updateTimerState();
  89          void armedState();
  90          void countdownState();
  91          void intruderState();
  92          
  93          //Function Prototypes
  94          void init_lcd();//initialize LCD
  95          void write_to_lcd(unsigned char value, bit mode);//write data or command
  96          void MSDelay(unsigned int itime);//delay 1 ms
  97          void lcdready(void);//check if lcd is ready to write to
  98          void displayTime(unsigned int time);
  99          void updateLCD(unsigned int time);//updates numbers
 100          void displayArmed();
 101          void displayDisarmed();
 102          void displayIntruder();
 103          void turnOnLaser();
 104          void turnOffLaser();
 105          void countDownTimer(int num);
 106          void turnOnAlarm();
 107          void turnOffAlarm();
 108          void flashIntruder();
 109          void soundAlarm();
 110          void resetTimer();
 111          
 112          
 113          void encoder() interrupt 0//
 114          { 
 115   1        if(EncB == 1)//cw
 116   1        {
C51 COMPILER V9.56.0.0   HOME_SECURITY_SYSTEM                                              12/07/2017 19:12:45 PAGE 3   

 117   2          dir = 1;
 118   2        }
 119   1        else//ccw
 120   1        {
 121   2          dir = -1;
 122   2        }
 123   1        update = 1;//update flag, interrupt will always show what direction
 124   1      }
 125          /**************************************************************/
 126          enum states//5 states
 127          {
 128            disarmed_state,
 129            update_timer_state,
 130            armed_state,
 131            countdown_state,
 132            intruder_state
 133          };
 134          enum states state = disarmed_state;
 135          /**************************************************************/
 136          void main(){
 137   1        //Interrupt enable
 138   1        EA = 1;
 139   1        ET1 = 1;
 140   1        //Timer enable
 141   1        TMOD = 0x10;//timer 1 mode 1
 142   1        TH1 = 0x4B;//high bit value
 143   1        TL1 = 0x92;//low bit value
 144   1        TR1 = 0;//turn off timer 0
 145   1        
 146   1        //enable external interrupts
 147   1        EX1 = 1;
 148   1        EX0 = 1;
 149   1        IT1 = 1;
 150   1        IT0 = 1;
 151   1        //Delcare inputs and outputs
 152   1        LED0 = 0;
 153   1        LED1 = 0;
 154   1        //turn off LEDS
 155   1        GREEN = 1;
 156   1        YELLOW = 1;
 157   1        RED = 1;
 158   1        //Turn off laser
 159   1        LaserSwitch = 0;
 160   1        
 161   1        init_lcd();
 162   1        //countDownTimer(12);
 163   1        //displayDisarmed();
 164   1        //countDownTimer(7);
 165   1        //intruderState();
 166   1        displayTime(countDownNum);
 167   1          while(1)
 168   1          {
 169   2            switch(state)
 170   2            {
 171   3              case disarmed_state:
 172   3                //call function
 173   3                disarmedState();
 174   3                //next state logic
 175   3                if(update == 1)
 176   3                {
 177   4                  state = update_timer_state;
 178   4                }
C51 COMPILER V9.56.0.0   HOME_SECURITY_SYSTEM                                              12/07/2017 19:12:45 PAGE 4   

 179   3                if(ARM == 1)
 180   3                {
 181   4                  prevTime = countDownNum;//save previous value
 182   4                  state = countdown_state;
 183   4                }
 184   3                break;
 185   3              case update_timer_state:
 186   3                //call function
 187   3                updateTimerState();
 188   3                //next state logic
 189   3                state = disarmed_state;
 190   3                break;
 191   3              case armed_state:
 192   3                //call function
 193   3                armedState();
 194   3                //next state logic
 195   3                if(ARM == 0)
 196   3                {
 197   4                  state = disarmed_state;
 198   4                }
 199   3                if(ARMED == 1 && Laser_Break == 1)
 200   3                {
 201   4                  state = countdown_state;
 202   4                }
 203   3                break;
 204   3              case countdown_state:
 205   3                //call function
 206   3                countdownState();
 207   3                //next state logic
 208   3                if(ARM == 0)
 209   3                {
 210   4                  state = disarmed_state;
 211   4                }
 212   3                if(ARMED == 0 && timer == 0)
 213   3                {
 214   4                  state = armed_state;
 215   4                }
 216   3                if(ARMED == 1 && timer == 0)//already armed and countdown is zero
 217   3                {
 218   4                  state = intruder_state;
 219   4                }
 220   3                break;
 221   3              case intruder_state:
 222   3                //call function
 223   3                intruderState();
 224   3                //next state logic
 225   3                if(ARM == 0)
 226   3                {
 227   4                  state = disarmed_state;
 228   4                }
 229   3                break;
 230   3              default:
 231   3                state = disarmed_state;
 232   3            }
 233   2          }
 234   1          
 235   1        
 236   1        
 237   1      
 238   1      
 239   1      }
 240          /**************************************************************/
C51 COMPILER V9.56.0.0   HOME_SECURITY_SYSTEM                                              12/07/2017 19:12:45 PAGE 5   

 241          ////////////////////////////////////////////////////////////////
 242          //                     State Functions                        //
 243          ////////////////////////////////////////////////////////////////
 244          
 245          void disarmedState()
 246          {
 247   1        //displayTime(countDownNum);
 248   1        delayOneTen();
 249   1        displayDisarmed();
 250   1        turnOffLaser();
 251   1        ARMED = 0;
 252   1        //turn off intruder LEDs
 253   1        LED0 = 0;
 254   1        LED1 = 0;
 255   1        //update timer LEDs
 256   1        GREEN = 0;
 257   1        RED = 1;
 258   1        YELLOW = 1;
 259   1        
 260   1      }
 261          void updateTimerState() //Fixme: No need for this state? Will wait for John's lecture
 262          {
 263   1        //FIXME: will the encoder just take it to this state?
 264   1        update = 0;//recognize that it is updating
 265   1        countDownNum = countDownNum + dir;//inc or decrease, always
 266   1        
 267   1        //check if in bounds
 268   1        if(countDownNum > 99)
 269   1        {
 270   2          countDownNum = 99;
 271   2        }
 272   1        if(countDownNum < 7)
 273   1        {
 274   2          countDownNum = 7;
 275   2        }
 276   1        updateLCD(countDownNum);//updateLCD with new num
 277   1        delayOneTen();
 278   1      }
 279          void armedState()
 280          {
 281   1        displayArmed();
 282   1        turnOnLaser();
 283   1        timer = 1;//not zero
 284   1        ARMED = 1;//armed flag
 285   1        updateLCD(prevTime);
 286   1      }
 287          void countdownState()
 288          {
 289   1        countDownNum = countDownNum - 1;//decrease counter
 290   1        updateLCD(countDownNum);
 291   1        //update timer flag
 292   1        if(countDownNum == 0)
 293   1        {
 294   2          timer = 0;
 295   2        }
 296   1        //update LEDs
 297   1        if(countDownNum >= 7)//green
 298   1        {
 299   2          GREEN = 0;
 300   2          YELLOW = 1;
 301   2          RED = 1;
 302   2        }
C51 COMPILER V9.56.0.0   HOME_SECURITY_SYSTEM                                              12/07/2017 19:12:45 PAGE 6   

 303   1        else if(countDownNum >= 4 && countDownNum <= 6)//yellow
 304   1        {
 305   2          GREEN = 1;
 306   2          YELLOW = 0;
 307   2          RED = 1;
 308   2        }
 309   1        else//RED
 310   1        {
 311   2          GREEN = 1;
 312   2          YELLOW = 1;
 313   2          RED = 0;
 314   2        }
 315   1        
 316   1      }
 317          void intruderState()
 318          {
 319   1        displayIntruder();
 320   1        while(ARM == 1)//alternate LEDs and don't change states
 321   1        {
 322   2          LED0 = 1;
 323   2          LED1 = 0;
 324   2          delayHalf();
 325   2          LED0 = 0;
 326   2          LED1 = 1;
 327   2          delayHalf();
 328   2        }
 329   1      }
 330          
 331          
 332          
 333          
 334          ////////////////////////////////////////////////////////////////
 335          //               LCD  Helper Functions                        //
 336          ////////////////////////////////////////////////////////////////
 337          void displayTime(unsigned int time)
 338          {
 339   1        //Converting and separating to what was passed in
 340   1        char msb = (time/10)+48;
 341   1        char lsb = (time%10)+48;
 342   1        
 343   1        unsigned char code timer[]="Timer:NA seconds";
 344   1        unsigned char t = 0;                                                                            
 345   1        
 346   1        //Writing first line
 347   1        write_to_lcd(0x80,COMMAND); //Move to start of first line
 348   1        while (timer[t]!='\0') 
 349   1         write_to_lcd(timer[t++],LCD_DATA);
 350   1      
 351   1        //Write to start of number on first line from left to right
 352   1        write_to_lcd(0x86,COMMAND); 
 353   1        write_to_lcd(msb,LCD_DATA); 
 354   1        write_to_lcd(lsb,LCD_DATA); 
 355   1      }
 356          
 357          
 358          //setup LCD for required display
 359          void init_lcd(){
 360   1        //all instructions here are commands, not data
 361   1        
 362   1        write_to_lcd(0x38,COMMAND);
 363   1      
 364   1        write_to_lcd(0x0E,COMMAND);
C51 COMPILER V9.56.0.0   HOME_SECURITY_SYSTEM                                              12/07/2017 19:12:45 PAGE 7   

 365   1        
 366   1        write_to_lcd(0x06,COMMAND);
 367   1        //clear display and return cursor to home position
 368   1        write_to_lcd(0x01,COMMAND);
 369   1      }
 370          
 371          void write_to_lcd(unsigned char value, bit mode){
 372   1        lcdready();
 373   1        ldata = value;
 374   1        rs = mode; //1 for data, 0 for command
 375   1        rw = 0;
 376   1        en = 1;
 377   1        MSDelay(1);
 378   1        en = 0;
 379   1      }
 380          void MSDelay(unsigned int itime){
 381   1        unsigned i, j;
 382   1        for(i=0;i<itime;i++)
 383   1          for(j=0;j<1275;j++);
 384   1      
 385   1      }
 386          void lcdready(){
 387   1        busy = 1;
 388   1        en = 1;
 389   1        rs = 0;//command
 390   1        rw = 1;//read command
 391   1        while(busy){
 392   2          en = 0;
 393   2          MSDelay(1);
 394   2          en = 1;
 395   2        }
 396   1        en = 0;
 397   1        rw = 0;
 398   1      }
 399          
 400          void updateLCD(unsigned int time)//updates numbers
 401          {
 402   1        char msb = (time/10)+48;
 403   1        char lsb = (time%10)+48;
 404   1          //Write to start of number on first line from left to right
 405   1        write_to_lcd(0x86,COMMAND); 
 406   1        write_to_lcd(msb,LCD_DATA); 
 407   1        write_to_lcd(lsb,LCD_DATA); 
 408   1      }
 409          
 410          void displayArmed()
 411          {
 412   1        unsigned char code msg[]="ARMED";
 413   1        unsigned char i=0;                                                                                 
 414   1      
 415   1        //Writing to second line
 416   1        write_to_lcd(0xC0,COMMAND);
 417   1        
 418   1        while (msg[i]!='\0') 
 419   1         write_to_lcd(msg[i++],LCD_DATA);
 420   1      }
 421          void displayDisarmed()
 422          {
 423   1        unsigned char code msg[]="DISARMED";
 424   1        unsigned char i=0;                                                                                      
 425   1      
 426   1        //Writing to second line
C51 COMPILER V9.56.0.0   HOME_SECURITY_SYSTEM                                              12/07/2017 19:12:45 PAGE 8   

 427   1        write_to_lcd(0xC0,COMMAND);
 428   1        
 429   1        while (msg[i]!='\0') 
 430   1         write_to_lcd(msg[i++],LCD_DATA);
 431   1      }
 432          void displayIntruder()
 433          {
 434   1        unsigned char code msg[]="INTRUDER!";
 435   1        unsigned char i=0;                                                                                    
 436   1      
 437   1        //Writing to second line
 438   1        write_to_lcd(0xC0,COMMAND);
 439   1        
 440   1        while (msg[i]!='\0') 
 441   1         write_to_lcd(msg[i++],LCD_DATA);
 442   1      }
 443          
 444          void turnOnLaser()
 445          {
 446   1        LaserSwitch = 1;
 447   1      }
 448          void turnOffLaser()
 449          {
 450   1        LaserSwitch = 0;
 451   1      }
 452          void countDownTimer(int time)
 453          {
 454   1        unsigned int count;
 455   1        
 456   1        //Converting and separating to what was passed in
 457   1        char msb = (time/10)+48;
 458   1        char lsb = (time%10)+48;
 459   1        
 460   1        unsigned char code timer[]="Timer:NA seconds";
 461   1        unsigned char t = 0;                                                                            
 462   1        
 463   1        //Writing first line
 464   1        write_to_lcd(0x80,COMMAND); //Move to start of first line
 465   1        while (timer[t]!='\0') 
 466   1         write_to_lcd(timer[t++],LCD_DATA);
 467   1        
 468   1        
 469   1        for (count = time; count >= 0; count--){    
 470   2          if (lsb < 0x30){
 471   3            lsb = 0x39;
 472   3            msb--;
 473   3            if (msb < 0x30){
 474   4              msb = 0x39;
 475   4            }
 476   3          }
 477   2          
 478   2          //Write to start of number on first line from left to right
 479   2          write_to_lcd(0x86,COMMAND); 
 480   2          write_to_lcd(msb,LCD_DATA);
 481   2          write_to_lcd(lsb,LCD_DATA);
 482   2          
 483   2          //turn on and off LEDS
 484   2          if(msb > 0x30 )//greater than 10, green
 485   2          {
 486   3            GREEN = 0;
 487   3            YELLOW = 1;
 488   3            RED = 1;
C51 COMPILER V9.56.0.0   HOME_SECURITY_SYSTEM                                              12/07/2017 19:12:45 PAGE 9   

 489   3          }
 490   2          else
 491   2          {
 492   3            if(lsb >= 0x34 && lsb <= 0x36)//4-6 yellow
 493   3            {
 494   4              GREEN = 1;
 495   4              YELLOW = 0;
 496   4              RED = 1;
 497   4            }
 498   3            else if(lsb >= 0x30 && lsb <= 0x33)//0-3 red
 499   3            {
 500   4              GREEN = 1;
 501   4              YELLOW = 1;
 502   4              RED = 0;
 503   4            }
 504   3            else//7-9 green
 505   3            {
 506   4              GREEN = 0;
 507   4              YELLOW = 1;
 508   4              RED = 1;
 509   4            }
 510   3          }
 511   2          
 512   2          //Keeps both numbers at 00
 513   2          if (msb == 0x30 && lsb == 0x30)
 514   2          {
 515   3            break;
 516   3          }
 517   2          
 518   2          lsb--; //Deccrementing least significant bit
 519   2          
 520   2          delay(); //1 second delay  
 521   2        }
 522   1      }
 523          
 524          void turnOnAlarm()
 525          {
 526   1      }
 527          void turnOffAlarm()
 528          {
 529   1      }
 530          void flashIntruder()
 531          {
 532   1      }
 533          void soundAlarm()
 534          {
 535   1      }
 536          void resetTimer()
 537          {
 538   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1039    ----
   CONSTANT SIZE    =     59    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     11      16
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
